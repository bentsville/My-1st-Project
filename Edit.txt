Transaction.java(model):

package com.example.bank.model;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.math.BigDecimal;
import java.time.Instant;

@Entity @Table(name="transactions")
@Getter @Setter
public class Transaction {
    @Id @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    public Transaction() {
    }

    @ManyToOne(optional = false)
    private User owner;

    public Transaction(Long id, User owner, Account account, Batch batch, String type, String beneficiaryName, String beneficiaryAccount, BigDecimal amount, String baseCurrency, String accountCurrency, String status, Instant createdAt, Instant updatedAt) {
        this.id = id;
        this.owner = owner;
        this.account = account;
        this.batch = batch;
        this.type = type;
        this.beneficiaryName = beneficiaryName;
        this.beneficiaryAccount = beneficiaryAccount;
        this.amount = amount;
        this.baseCurrency = baseCurrency;
        this.accountCurrency = accountCurrency;
        this.status = status;
        this.createdAt = createdAt;
        this.updatedAt = updatedAt;
    }

    @ManyToOne(optional = false)
    private Account account;

    @ManyToOne
    private Batch batch;

    @Column(nullable = false)
    private String type; // PAY

    @Column(nullable = false)
    private String beneficiaryName;

    @Column(nullable = false)
    private String beneficiaryAccount;

    @Column(nullable = false)
    private BigDecimal amount;

    private String baseCurrency;
    private String accountCurrency;

    @Column(nullable = false)
    private String status = "DRAFT"; // DRAFT, SUBMITTED, APPROVED, REJECTED, PROCESSED

    private Instant createdAt = Instant.now();
    private Instant updatedAt = Instant.now();

    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public User getOwner() {
        return owner;
    }

    public void setOwner(User owner) {
        this.owner = owner;
    }

    public Account getAccount() {
        return account;
    }

    public void setAccount(Account account) {
        this.account = account;
    }

    public Batch getBatch() {
        return batch;
    }

    public void setBatch(Batch batch) {
        this.batch = batch;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public String getBeneficiaryName() {
        return beneficiaryName;
    }

    public void setBeneficiaryName(String beneficiaryName) {
        this.beneficiaryName = beneficiaryName;
    }

    public String getBeneficiaryAccount() {
        return beneficiaryAccount;
    }

    public void setBeneficiaryAccount(String beneficiaryAccount) {
        this.beneficiaryAccount = beneficiaryAccount;
    }

    public BigDecimal getAmount() {
        return amount;
    }

    public void setAmount(BigDecimal amount) {
        this.amount = amount;
    }

    public String getBaseCurrency() {
        return baseCurrency;
    }

    public void setBaseCurrency(String baseCurrency) {
        this.baseCurrency = baseCurrency;
    }

    public String getAccountCurrency() {
        return accountCurrency;
    }

    public void setAccountCurrency(String accountCurrency) {
        this.accountCurrency = accountCurrency;
    }

    public String getStatus() {
        return status;
    }

    public void setStatus(String status) {
        this.status = status;
    }

    public Instant getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(Instant createdAt) {
        this.createdAt = createdAt;
    }

    public Instant getUpdatedAt() {
        return updatedAt;
    }

    public void setUpdatedAt(Instant updatedAt) {
        this.updatedAt = updatedAt;
    }

    @PreUpdate
    public void onUpdate() { this.updatedAt = Instant.now(); }
}



TransactionService.java (service):

package com.example.bank.service;

import com.example.bank.model.*;
import com.example.bank.repository.*;
import org.springframework.stereotype.Service;
import org.springframework.web.multipart.MultipartFile;
import jakarta.transaction.Transactional;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.math.BigDecimal;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Optional;

@Service
public class TransactionService {
    private final TransactionRepository txnRepo;
    private final AccountRepository accountRepo;
    private final BatchRepository batchRepo;
    private final UserRepository userRepo;

    public TransactionService(TransactionRepository txnRepo, AccountRepository accountRepo, BatchRepository batchRepo, UserRepository userRepo) {
        this.txnRepo = txnRepo;
        this.accountRepo = accountRepo;
        this.batchRepo = batchRepo;
        this.userRepo = userRepo;
    }

    @Transactional
    public Transaction createTransaction(Long userId, Transaction transactionRequest, boolean submit) {
        // 1. Find the user entity
        User owner = userRepo.findById(userId)
                .orElseThrow(() -> new IllegalArgumentException("User not found with id: " + userId));

        // 2. Create and populate a new Transaction entity
        Transaction newTransaction = new Transaction();
        newTransaction.setOwner(owner);
        newTransaction.setAmount(transactionRequest.getAmount());
        newTransaction.setBeneficiaryAccount(transactionRequest.getBeneficiaryAccount());
        newTransaction.setBeneficiaryName(transactionRequest.getBeneficiaryName());
        newTransaction.setType(transactionRequest.getType());
        newTransaction.setAccount(transactionRequest.getAccount()); // Assuming account is passed correctly
        newTransaction.setBaseCurrency(transactionRequest.getBaseCurrency());
        newTransaction.setAccountCurrency(transactionRequest.getAccountCurrency());

        // Set the status based on the `submit` flag
        newTransaction.setStatus(submit ? "SUBMITTED" : "DRAFT");

        // The @PrePersist and @PreUpdate lifecycle annotations in your Transaction model will handle
        // createdAt and updatedAt automatically.

        // 3. Save the new transaction and return the persisted entity
        return txnRepo.save(newTransaction);
    }


    public Transaction createOrUpdate(Long userId, Transaction t, boolean submit) {
        User u = userRepo.findById(userId).orElseThrow();
        t.setOwner(u);
        if (t.getId() == null) {
            t.setStatus(submit ? "SUBMITTED" : "DRAFT");
        } else if (submit) {
            t.setStatus("SUBMITTED");
        }
        return txnRepo.save(t);
    }

    public List<Transaction> uploadCsv(Long userId, MultipartFile file, String batchName) throws Exception {
        User u = userRepo.findById(userId).orElseThrow();
        Batch batch = new Batch();
        batch.setName(batchName == null ? "Batch-" + Instant.now().toString() : batchName);
        batch.setOwner(u);
        batch = batchRepo.save(batch);

        List<Transaction> created = new ArrayList<>();
        try (BufferedReader br = new BufferedReader(new InputStreamReader(file.getInputStream(), StandardCharsets.UTF_8))) {
            String line;
            int row = 0;
            while ((line = br.readLine()) != null) {
                row++;
                if (row == 1 && line.toLowerCase().contains("account_number")) continue; // header
                String[] parts = line.split(",");
                if (parts.length < 6) continue;
                String accountNumber = parts[0].trim();
                String type = parts[1].trim();
                String beneficiaryName = parts[2].trim();
                String beneficiaryAcct = parts[3].trim();
                BigDecimal amount = new BigDecimal(parts[4].trim());
                String currency = parts[5].trim();

                Account acct = accountRepo.findByAccountNumber(accountNumber);
                if (acct == null) continue;

                Transaction t = new Transaction();
                t.setOwner(u);
                t.setAccount(acct);
                t.setBatch(batch);
                t.setType(type);
                t.setBeneficiaryName(beneficiaryName);
                t.setBeneficiaryAccount(beneficiaryAcct);
                t.setAmount(amount);
                t.setBaseCurrency(currency);
                t.setAccountCurrency(acct.getCurrency());
                t.setStatus("DRAFT");
                created.add(txnRepo.save(t));
            }
        }
        return created;
    }

    public List<Transaction> findAllByUser(Long userId) {
        User u = userRepo.findById(userId).orElseThrow();
        return txnRepo.findByOwner(u);
    }

    public List<Transaction> findPendingApprovals(Long userId) {
        User u = userRepo.findById(userId).orElseThrow();
        return txnRepo.findByOwnerAndStatus(u, "SUBMITTED");
    }

    public Transaction approve(Long id) {
        Transaction t = txnRepo.findById(id).orElseThrow();
        t.setStatus("APPROVED");
        return txnRepo.save(t);
    }

    public Transaction reject(Long id) {
        Transaction t = txnRepo.findById(id).orElseThrow();
        t.setStatus("REJECTED");
        return txnRepo.save(t);
    }

    public List<Transaction> statement(Long accountId, Instant from, Instant to) {
        Account acct = accountRepo.findById(accountId).orElseThrow();
        return txnRepo.findByAccountAndCreatedAtBetween(acct, from, to);
    }

    public Transaction updateTransaction(Long id, Long userId, Transaction t) {
        User u = userRepo.findById(userId).orElseThrow();
        t.setOwner(u);

        t.setStatus("SUBMITTED");

        return txnRepo.save(t);

    }
}



TransactionController.java (controller):

package com.example.bank.controller;

import com.example.bank.model.Transaction;
import com.example.bank.model.User;
import com.example.bank.service.TransactionService;
import jakarta.servlet.http.HttpSession;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotNull;
import org.springframework.format.annotation.DateTimeFormat;
import org.springframework.http.MediaType;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.multipart.MultipartFile;

import java.time.Instant;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/transactions")
public class TransactionController {

    private final TransactionService transactionService;

    public TransactionController(TransactionService transactionService) {
        this.transactionService = transactionService;
    }

    @PostMapping
    public Transaction createTransaction(@RequestBody @Valid Transaction transaction,
                                         @RequestParam(value = "submit", defaultValue = "false") boolean submit) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        Long userId = ((User) authentication.getPrincipal()).getId();
        return transactionService.createTransaction(userId, transaction, submit);
    }

    @PutMapping("/{id}")
    public Transaction updateTransaction(@PathVariable Long id, @RequestBody @Valid Transaction t) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        Long userId = ((User) authentication.getPrincipal()).getId();
        return transactionService.updateTransaction(id, userId, t);
    }



    @GetMapping
    public List<Transaction> list(){
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        Long userId = ((User)authentication.getPrincipal()).getId();
        return transactionService.findAllByUser(userId);
    }

    @PostMapping(value="/upload", consumes = MediaType.MULTIPART_FORM_DATA_VALUE)
    public Map<String, Object> upload(@RequestPart("file") MultipartFile file,
                                      @RequestParam(required = false) String batchName,
                                      HttpSession session) throws Exception {
        Long userId = (Long) session.getAttribute("USER_ID");
        var created = transactionService.uploadCsv(userId, file, batchName);
        return Map.of("count", created.size());
    }

    @PostMapping("/{id}/submit")
    public Transaction submit(@PathVariable Long id, HttpSession session){
        Long userId = (Long) session.getAttribute("USER_ID");
        Transaction t = new Transaction();
        t.setId(id);
        return transactionService.createOrUpdate(userId, t, true);
    }

    @GetMapping("/approvals")
    public List<Transaction> approvals(HttpSession session){
        Long userId = (Long) session.getAttribute("USER_ID");
        return transactionService.findPendingApprovals(userId);
    }

    @PostMapping("/{id}/approve")
    public Transaction approve(@PathVariable Long id){
        return transactionService.approve(id);
    }

    @PostMapping("/{id}/reject")
    public Transaction reject(@PathVariable Long id){
        return transactionService.reject(id);
    }
}



SecurityConfig.java (config):

package com.example.bank.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import org.springframework.security.web.context.SecurityContextHolderFilter;

import java.util.Arrays;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthFilter;
    private final AuthenticationProvider authenticationProvider;

    public SecurityConfig(JwtAuthenticationFilter jwtAuthFilter, AuthenticationProvider authenticationProvider) {
        this.jwtAuthFilter = jwtAuthFilter;
        this.authenticationProvider = authenticationProvider;
    }

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http

                .cors(cors -> cors.configurationSource(corsConfigurationSource()))
                .csrf(csrf -> csrf.disable()) // Disable CSRF for stateless APIs
                .authorizeHttpRequests(auth -> auth
                        // Allow login and registration endpoints to be public
                        .requestMatchers("/api/auth/login", "/api/auth/create", "/api/auth/me", "/api/users").permitAll()
                        .requestMatchers(HttpMethod.POST, "/api/transactions/createOrUpdate").hasAuthority("ADMIN")
                        .anyRequest().authenticated() // All other requests must be authenticated
//                        .anyRequest().permitAll()
                )
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)) // Use stateless sessions
                .authenticationProvider(authenticationProvider)
                .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);




        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("http://localhost:3000"));
        configuration.setAllowedMethods(Arrays.asList("GET", "POST", "PUT", "DELETE", "OPTIONS"));
        configuration.setAllowedHeaders(Arrays.asList("Authorization", "Content-Type"));
        configuration.setAllowCredentials(true);
        configuration.setMaxAge(3600L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", configuration); // Or "/**"
        return source;
    }
}